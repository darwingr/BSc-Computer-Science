/* main.cpp
 * --------
 * CSCI 355 Algorithm Analysis
 * Lab 6    m-Coloring Problem
 *
 * Authors: Darwin Jacob Groskleg
 * Date:    Wednesday, March 13, 2019
 *
 * QUESTIONS: are answered in the comments of main().
 *
 * CONSOLE:
 * > make
 * > ./bin/Lab06-Coloring
 *  [1]: 
 *  [2]: 
 *  [3]: 2 1 2 1 1 3 1 1 3 3 3 1 2 2 2 1 2 2 2 1 2 1 1 1 1 3 1 3 3 3 1 3 2 2 1 
 *  2 3 1 3 3 1 1 2 2 2 3 2 2 1 1 2 1 3 3 3 2 1 1 2 1 3 2 3 3 2 1 1 1 3 2 3 3 2 
 *  2 1 2 2 2 3 3 1 1 3 1 2 3 2 2 1 3 1 1 1 3 1 3 3 3 3 2 3 2 2 2 3 2 2 2 3 1 1 
 *  1 3 3 1 3 3 2 3 2 
 *
 *  Nodes visited for m=3 : 538 in a search tree of 88572 nodes.
 *  Thus 88034 nodes have been pruned!
 *
 *  IMPROVED algorithm:
 *  Nodes visited for m=3 : 10 in a search tree of 29524 nodes.
 *  Thus 29514 nodes have been pruned!
 */
#include "graph.hpp"

#include <iostream>
#include <cmath>

int m_color_visits(int i, int n, int m);
namespace improved {
    int m_color_visits(int i, int n, int m);
}; // namespace my

using namespace std;

int main() {
    // 1. Determine the minimum number of colors required to color this graph.
    //
    //      The minimum number of colours is 3.
    //      Since there is no output from m < 3.
    for (int m=1; m<=3; m++) {
        cout << "[" << m << "]: ";
        m_color(0, GRAPH_NODES, m);
        cout << '\n';
    }
    cout << '\n';

    // 2. How many nodes are in the search tree?
    //
    //      Summation(n=1..GRAPH_NODES, m^n)
    //        = Summation(n=1..10, 3^n)
    //        = 3^1 + ... + 3^10
    //        = 88,572 nodes in the search tree
    //      for the smallest number of colours m=3.
    int search_tree_nodes = 0;
    for (int n=1; n<=GRAPH_NODES; n++)
        search_tree_nodes += pow(3, n);

    // 3. How many nodes are pruned by the promising algorithm above?
    //
    //      88,034 nodes have been pruned!
    int node_count = m_color_visits(0, GRAPH_NODES, 3);
    cout << "Nodes visited for m=3 : " << node_count
        << " in a search tree of " << search_tree_nodes << " nodes.\n"
        << "Thus " << search_tree_nodes - node_count
        << " nodes have been pruned!\n\n";

    // 4. With symmetries, many colorings are the same. What are a couple of
    //    quick enhancements that can be made to further prune the search space
    //    to not create the “same” colorings?
    //
    //    We can do a couple of things:
    //      1. Recognize the colour number patterns as more significant than the
    //         colour numbers themselves. These are cyclic groups.
    //
    //      2. Always start with colour 1 for the first vertex then for
    //         subsequent vertices only attempt to match colours that are a
    //         lesser number than the vertex since.
    //
    //    Search tree size:
    //      Summation(n=0..GRAPH_NODES-1, m^n)
    //        = Summation(n=0..9, 3^n)
    //        = 3^0 + ... + 3^9
    //        = 29,524 nodes for the smallest number of colours m=3.
    search_tree_nodes = 0;
    for (int n=0; n<GRAPH_NODES; n++)
        search_tree_nodes += pow(3, n);

    // 5. Now how many nodes are visited by the algorithm?
    //
    //      The algorithm visits 10 nodes!
    node_count = improved::m_color_visits(0, GRAPH_NODES, 3);
    cout << "IMPROVED algorithm:\n"
        << "Nodes visited for m=3 : " << node_count
        << " in a search tree of " << search_tree_nodes << " nodes.\n"
        << "Thus " << search_tree_nodes - node_count
        << " nodes have been pruned!\n";


    return 0;
}

/// m_color_visits
///
/// Returns the number of nodes visited in the same search tree generated by
/// m_color() in graph.hpp
/// Arguments:
///     i - some vertex in the graph
///     n - number of vertices in the graph
///     m - maximum number of colours to colour the graph with
int m_color_visits(int i, int n, int m) {
    int visits = 0;
    if (i == n)
        return visits;
    else {
        visits++;
        for (int c=1; c <= m; c++)
            if (promising(i,c)) {
                color[i] = c;
                visits += m_color_visits(i+1, n, m);
            }
    }
    return visits;
}

/// improved::m_color_visits
///
/// Returns the number of nodes visited using a more sophisticated pruning
/// method than what's used in m_color() in graph.hpp
/// Arguments:
///     i - some vertex in the graph
///     n - number of vertices in the graph
///     m - maximum number of colours to colour the graph with
int improved::m_color_visits(int i, int n, int m) {
    int visits = 0;
    if (i == n)
        return visits;
    else {
        visits++;
        for (int c=1; c <= m; c++)
            if (i<c && promising(i,c)) {
                color[i] = c;
                visits += m_color_visits(i+1, n, m);
            }
    }
    return visits;
}
